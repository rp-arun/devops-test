# Helm Applications Terraform Module

This repo deploys kubernetes applications using terraform and the [`helm`](https://helm.sh/) package manager.

## Applications

The following is a list of applications managed by this module:

- [Argo Workflows](https://github.com/bitnami/charts/tree/master/bitnami/argo-workflows)
- [AWS Cluster Autoscaler](https://github.com/credmark/helm-charts/tree/main/charts/cluster-autoscaler)
- [Kubernetes Dashboard](https://artifacthub.io/packages/helm/k8s-dashboard/kubernetes-dashboard)

## Usage

Install terraform dependencies (first time or whenever changes made to [versions.tf](./versions.tf)):

```shell
terraform init
```

Preview what terraform will apply:

```shell
terraform plan
```

Apply and build resources:

```shell
terraform apply
```

## Argo Workflows

Terraform will create an admin role for logging into Argo. The login token can be generated by running the following:

```shell
SECRET=$(kubectl get sa -n argo argo-workflows-workflow-admin -o=jsonpath='{.secrets[0].name}')
ARGO_TOKEN="Bearer $(kubectl get secret -n argo $SECRET -o=jsonpath='{.data.token}' | base64 --decode)"

echo $ARGO_TOKEN
```

This will output the login token which can be used to login into the Argo UI.

The UI will be exposed via a load balancer but can also be access via localhost by running this command:

```shell
kubectl -n argo port-forward service/argo-workflows-server 8081:80
```

And then navigating to [http://localhost:8081/](http://localhost:8081/)

## Kubernetes Dashboard

Currently deployed as an internal service that can be accessed on local machine via port-forwarding or proxy. Simplest way to access locally is to use port-forwarding with the following command:

```{bash}
kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8080:443
```

Then, navigate to [https://localhost:8080/](https://localhost:8080/)

> **NOTE**: If you get an error about invalid certs, then you likely need to enable an option in your browser for allowing invalid certificates to load when accessing via localhost.
> If using Brave or Chrome, enter this into the browser:
> [chrome://flags/#allow-insecure-localhost](chrome://flags/#allow-insecure-localhost)
> (if you are using Brave, replace "chrome" with "brave", though it should auto-replace it for you)
> then simply enable the option for "Allow invalid certificates for resources loaded from localhost."

To login, you will need to get an access token. You can run the following to generate the token:

```{bash}
kubectl get secret -n kubernetes-dashboard $(kubectl get serviceaccount -n kubernetes-dashboard kubernetes-dashboard -o jsonpath="{.secrets[0].name}") -o jsonpath="{.data.token}" | base64 --decode
```

In the login screen, select the "token" option and paste the token to login.

## Argo Events

There were some issues encountered installing argo-events using a helm chart so it was instead installed manually using the docs from [here](https://argoproj.github.io/argo-events/installation/).

The commands run were:

```{bash}
# using namespace installation
kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/manifests/namespace-install.yaml

# deploy the eventbus
kubectl apply -n argo-events -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/eventbus/native.yaml
```

## Troubleshooting

### Namespaces

If you try deleting a k8s namespace and it is stuck in "terminating" state, then you can force delete it by running the following:

```{bash}
NAMESPACE=<namespace>
kubectl proxy &
kubectl get namespace $NAMESPACE -o json |jq '.spec = {"finalizers":[]}' >temp.json
curl -k -H "Content-Type: application/json" -X PUT --data-binary @temp.json 127.0.0.1:8001/api/v1/namespaces/$NAMESPACE/finalize
```

### Unable to kubectl delete the eventbus

Deleted using [this](https://github.com/argoproj/argo-events/issues/1348#issuecomment-979361822) method.
